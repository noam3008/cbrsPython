'''
Created on Apr 20, 2017

@author: iagmon
'''

from model.Utils.Assert import Assertion 
import model.Utils.JsonComparisonUtils as jsonComparer
from controllers.CLIUtils.QuestionHandler import QuestionHandler
import logging
import model.Utils.Consts as consts


class MyEngine(object):

    def __init__(self,testDefinition,confFile,dirPath,currentLogger):
        '''
        Will recieve the test structure (the list of the json file and the step defintions). 
        Will read all the json files and save it as some structure.
        '''
        self.numberOfStep                       = 0
        self.numberOfHearbeatRequests           = 0
        self.testDefinietion                    = testDefinition
        self.validationErrorAccuredInEngine     = False
        self.isLastStepInCSV                    = False
        self.firstHeartbeatStep                 = True
        self.confFile                           = confFile
        self.dirPath                            = dirPath
        self.heartBeatLimitCounter              = confFile.getElementsByTagName("heartbeatLimit")[0].firstChild.data
        self.currentLogger                      = currentLogger
        self.assertion                          = Assertion(confFile,dirPath,currentLogger)
        self.repeatesAloowed                    = False
        self.repeatsType                        = None
        self.oldHttpReq                         = None

    def process_request(self,httpRequest,typeOfCalling):
        '''
        This will received the request that 
        arrived from the eNodeB,
         will assert the request according to the json file and in case the assert was successful,
          will return the response from the json file        '''
        try:               
            if(self.repeatsType == typeOfCalling and self.repeatesAloowed == True and self.oldHttpReq == httpRequest):
                print "1"
                if(typeOfCalling == consts.HEART_BEAT_SUFFIX_HTTP):
                    if(int(self.numberOfHearbeatRequests)<int(self.heartBeatLimitCounter)):
                        self.numberOfHearbeatRequests+=1
                    else:
                        return consts.HEART_BEAT_TIMEOUT_MESSAGE
                self.numberOfStep-=1       
                self.compare_Json_Req(httpRequest,self.get_Expected_Json_File_Name(),typeOfCalling)
            
        elif(self.Is_Repeats_Available(self.get_Expected_Json_File_Name())):                  
                if(typeOfCalling == consts.SPECTRUM_INQUIERY_SUFFIX_HTTP):
                    print "2"
                    if(self.Is_Repeats_Available(self.get_Expected_Json_File_Name())):
                        self.Initialize_Repeats_Type_Allowed(consts.SPECTRUM_INQUIERY_SUFFIX_HTTP,httpRequest, typeOfCalling)
                        self.compare_Json_Req(httpRequest,self.get_Expected_Json_File_Name(),typeOfCalling)
                elif(typeOfCalling == consts.HEART_BEAT_SUFFIX_HTTP):
                    print "3"          
                    if(self.Is_Repeats_Available(self.get_Expected_Json_File_Name())):
                        self.Initialize_Repeats_Type_Allowed(consts.HEART_BEAT_SUFFIX_HTTP,httpRequest, typeOfCalling) 
                        self.compare_Json_Req(httpRequest,self.get_Expected_Json_File_Name(),typeOfCalling)             
            else:
                print "4"
                self.repeatesAloowed = False
                self.repeatsType = None
                self.compare_Json_Req(httpRequest,self.get_Expected_Json_File_Name(),typeOfCalling)
        except Exception:
            self.validationErrorAccuredInEngine = True  
            return consts.ERROR_VALIDATION_MESSAGE
        self.oldHttpReq = httpRequest
        return self.process_response(typeOfCalling)

    def Is_Repeats_Available(self,expectedJsonName):
        return self.assertion.is_Heart_Beat_Request_Includes_Repeates(expectedJsonName)

    def compare_Json_Req(self,httpRequest,expectedJsonFileName,typeOfCalling):
        self.assertion.compare_Json_Req(httpRequest,expectedJsonFileName,typeOfCalling+consts.REQUEST_NODE_NAME)
        
        
    def process_response(self,typeOfCalling):
        '''
        This will received the request that 
        arrived from the eNodeB,
         will assert the request according to the json file and in case the assert was successful,
          will return the response from the json file
        '''      
        '''if(typeOfCalling == "heartbeat"):
            if(self.firstHeartbeatStep):
                self.firstHeartbeatStep = False
            return self.parse_Json_To_Dic_By_File_Name(consts.HEART_BEAT_SUFFIX_HTTP + consts.SUFFIX_OF_JSON_FILE, consts.RESPONSE_NODE_NAME,self.confFile)'''
            
        
        jsonAfterParse = self.parse_Json_To_Dic_By_File_Name(self.get_Expected_Json_File_Name(),consts.RESPONSE_NODE_NAME,self.confFile)
        if(len(self.testDefinietion.jsonNamesOfSteps) == self.numberOfStep+1):
            self.currentLogger.print_And_Log_To_File(consts.NSTEP_SESSION_WITH_TECHNITIAN,True)
            self.questAnswerPartOfJson = self.parse_Json_To_Dic_By_File_Name(self.get_Expected_Json_File_Name(),consts.QUESTION_NODE_NAME,self.confFile)
            self.isLastStepInCSV = True
    
        self.numberOfStep+=1
        return jsonAfterParse
    
    def parse_Json_To_Dic_By_File_Name(self,jsonFileName,nodeName,confFile):
        return jsonComparer.parse_Json_To_Dic(jsonFileName,nodeName,confFile,self.dirPath)
    
    def get_Expected_Json_File_Name(self):
        return self.testDefinietion.jsonNamesOfSteps[self.numberOfStep]
    
    def get_Question_Answer_Part(self):
        return self.questAnswerPartOfJson
    
    
    def Initialize_Repeats_Type_Allowed(self,repeatType, httpRequest, typeOfCalling):
        self.repeatsType = repeatType
        self.repeatesAloowed = True
        self.compare_Json_Req(httpRequest, self.get_Expected_Json_File_Name(), typeOfCalling)
    
    
    